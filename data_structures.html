<!DOCTYPE html>
<html>

<head>
	<style type="text/css">
		body {
			margin: 0;
			padding: 0;
			font-size: 16px;
			font-family: 'Liberation Serif';
		}
		.chapter {
			background: #fbf7f7;
			margin: 0;
			border: 0 solid gray;
		}
		h1, h2, h3, h4, p {
			margin: 0;
			padding: 4px;
		}
		ul {
			margin: 0 30px;
			padding: 4px;
		}
		pre {
			margin: 5px 0;
			padding: 4px;
			background: #f0ebeb;
		}
		.wrapper {
			max-width: 1000px;
			margin: auto;	
		}
	</style>
	<meta charset="utf-8">
</head>

<body><div class="wrapper">

	<div class="chapter"><h2>Числа</h2>
		<h3>Способы записи</h3>
		<pre><code>alert(0xFF); // 255 в шестнадцатиричной системе</code></pre>
		<pre><code>// еще пример научной формы: 3 с 5 нулями
alert(3e5); // 300000</code></pre>
		<pre><code>// здесь 3 сдвинуто 5 раз вправо, за десятичную точку.
alert(3e-5); // 0.00003  <-- 5 нулей, включая начальный ноль</code></pre>
		<h3>isFinite(n)</h3>
		<p>Функция <code>isFinite(n)</code> преобразует аргумент к числу и возвращает <code>true</code>, если это не <code>NaN/Infinity/-Infinity</code>:</p>
		<pre><code>alert(isFinite(1)); // true
alert(isFinite(Infinity)); // false
alert(isFinite(NaN)); // false</code></pre>
		<h3>Мягкое преобразование: parseInt и parseFloat</h3>
		<p>Функция <code>parseInt</code> и ее аналог <code>parseFloat</code> преобразуют строку символ за символом, пока это возможно.</p>
		<pre><code>alert(parseInt('12px')); // 12, ошибка на символе 'p'
alert(parseFloat('12.3.4')); // 12.3, ошибка на второй точке</code></pre>
		<h3>Проверка на число</h3>
		<p>Для проверки строки на число можно использовать функцию <code>isNaN(str)</code>.</p>
		<p>Она преобразует строку в число аналогично <code>+</code>, а затем вернёт <code>true</code>, если это <code>NaN</code>, то есть если преобразование не удалось</p>
		<h3>toString(система счисления)</h3>
		<p>Числа можно записывать не только в 10-ричной, но и в 16-ричной системе. Но бывает и противоположная задача: получить 16-ричное представление числа. Для этого используется метод <code>toString(основание системы)</code>, например:</p>
		<pre><code>alert(255.toString(16)); // ff</code></pre>
		<h3>Округление</h3>
		<p><b>Math.floor</b></p>
		<p>Округляет вниз</p>
		<p><b>Math.ceil</b></p>
		<p>Округляет вверх</p>
		<p><b>Math.round</b></p>
		<p>Округляет до ближайшего целого</p>
		<pre><code>alert(Math.floor(3.1));  // 3
alert(Math.ceil(3.1));   // 4
alert(Math.round(3.1));  // 3</code></pre>
		<h3>num.toFixed(precision)</h3>
		<p>Существует также специальный метод <code>num.toFixed(precision)</code>, который округляет число <code>num</code> до точности <code>precision</code> и возвращает результат в виде строки:</p>
		<pre><code>var n = 12.34;
alert(12.toFixed(1)); // "12.3"</code></pre>
		<h3>Форматирование</h3>
		<p>Для красивого вывода чисел в стандарте ECMA 402 есть метод <code>toLocaleString()</code>:</p>
		<pre><code>var number = 123456789;
alert(number.toLocaleString()); // 123 456 789</code></pre>
	</div>

	<div class="chapter"><h2>Строки</h2>
		<h3>Доступ к символам</h3>
		<p>Чтобы получить символ, используйте вызов <code>charAt(позиция)</code>. Первый символ имеет позицию <code>0</code>:</p>
		<pre><code>alert("jQuery".charAt(0)); // "j"</code></pre>
		<h3>Смена регистра</h3>
		<p>Методы <code>toLowerCase()</code> и <code>toUpperCase()</code> меняют регистр строки на нижний/верхний:</p>
		<pre><code>alert("Интерфейс".toUpperCase()); // ИНТЕРФЕЙС</code></pre>
		<h3>Поиск подстроки</h3>
		<p>Для поиска подстроки есть метод <code>indexOf(подстрока[, начальная_позиция])</code>.</p>
		<pre><code>alert("Widget with id".indexOf("id")); // 1, т.к. "id" найден, начиная с позиции 1</code></pre>
		<h3>Взятие подстроки: substring, substr, slice</h3>
		<p><b>substring(start [, end])</b></p>
		<p>Метод <code>substring(start, end)</code> возвращает подстроку с позиции <code>start</code> до, но не включая <code>end</code>. Отрицательные аргументы интерпретируются как равные 0, но слишком длинные значения усекаются до длины строки.</p>
		<pre><code>alert("stringify".substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1</code></pre>
		<p><b>substr(start [, length])</b></p>
		<p>Первый аргумент имеет такой же смысл, как и в <code>substring</code>, а второй содержит не конечную позицию, а количество символов. Если второго аргумента нет – подразумевается «до конца строки».</p>
		<pre><code>alert("stringify".substr(2,4)); // ring, со 2-й позиции 4 символа</code></pre>
		<p><b>slice(start [, end])</b></p>
		<p>Возвращает часть строки от позиции <code>start</code> до, но не включая, позиции <code>end</code>. Смысл параметров – такой же как в <code>substring</code>.</p>
		<pre><code>alert("stringify".slice(0,1));</code></pre>
		<h3>Отрицательные аргументы</h3>
		<p>Различие между <code>substring</code> и <code>slice</code> – в том, как они работают с отрицательными и выходящими за границу строки аргументами:</p>
		<p><b>substring(start, end)</b></p>
		<p>Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:</p>
		<pre><code>alert("testme".substring(-2)); // "testme", -2 становится 0</code></pre>
		<p>Кроме того, если <code>start > end</code>, то аргументы меняются местами, т.е. возвращается участок строки между <code>start</code> и <code>end</code>:</p>
		<pre><code>alert("testme".substring(4, -1)); // "test"
// -1 становится 0 -> получили substring(4, 0)
// 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"</code></pre>
		<p><b>slice(start, end)</b></p>
		<p>Отрицательные значения отсчитываются от конца строки:</p>
		<pre><code>alert("testme".slice(-2)); // "me", от 2 позиции с конца</code></pre>
		<pre><code>alert("testme".slice(1, -1)); // "estm", от 1 позиции до первой с конца.</code></pre>
	</div>

	<div class="chapter"><h2>Массивы. Методы pop/push, shift/unshift</h2>
		<h3>Конец массива</h3>
		<p><b>pop</b></p>
		<p>Удаляет последний элемент из массива и возвращает его:</p>
		<pre><code>var fruits = ["Яблоко", "Апельсин", "Груша"];
alert(fruits.pop()); // удалили "Груша"
alert(fruits); // Яблоко, Апельсин</code></pre>
		<p><b>push</b></p>
		<p>Добавляет элемент в конец массива:</p>
		<pre><code>var fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert(fruits); // Яблоко, Апельсин, Груша</code></pre>
		<h3>Начало массива</h3>
		<p><b>shift</b></p>
		<p>Удаляет из массива первый элемент и возвращает его:</p>
		<pre><code>var fruits = ["Яблоко", "Апельсин", "Груша"];
alert(fruits.shift()); // удалили Яблоко
alert(fruits); // Апельсин, Груша</code></pre>
		<p><b>unshift</b></p>
		<p>Добавляет элемент в начало массива:</p>
		<pre>var fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert(fruits); // Яблоко, Апельсин, Груша</pre>
	</div>

	<div class="chapter"><h2>Массивы. Встроенные методы массивов</h2>
		<h3>Метод split</h3>
		<p>Превращает строку в массив, разбив её е по разделителю. Также есть 2й необязательный аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен.</p>
		<pre><code>var names = 'Маша, Петя, Марина, Василий';
var arr = names.split(', '); // arr = [Маша, Петя, Марина, Василий]</code></pre>
		<h3>Метод join</h3>
		<p>Вызов <code>arr.join(str)</code> делает в точности противоположное <code>split</code>. Он берет массив и склеивает его в строку, используя <code>str</code> как разделитель.</p>
		<pre><code>var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
var str = arr.join(';');
alert(str); // Маша;Петя;Марина;Василий</code></pre>
		<h3>Метод splice</h3>
		<p>Метод <code>splice</code> – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.</p>
		<p><code>arr.splice(index[, deleteCount, elem1, ..., elemN])</code></p>
		<p>Удалить <code>deleteCount</code> элементов, начиная с номера <code>index</code>, а затем вставить <code>elem1, ..., elemN</code> на их место. Возвращает массив из удалённых элементов.</p>
		<p>Начнём с удаления:</p>
		<pre><code>var arr = ["Я", "изучаю", "JavaScript"];
// начиная с позиции 1, удалить 1 элемент
arr.splice(1, 1); // осталось ["Я", "JavaScript"]</code></pre>
		<p>В следующем примере мы удалим 3 элемента и вставим другие на их место:</p>
		<pre><code>var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
// удалить 3 первых элемента и добавить другие вместо них
arr.splice(0, 3, "Мы", "изучаем"); // теперь ["Мы", "изучаем", "JavaScript"]</code></pre>
		<p>Здесь видно, что <code>splice</code> возвращает массив из удаленных элементов:</p>
		<pre><code>var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
// удалить 2 первых элемента
var removed = arr.splice(0, 2); // removed = ["Я", "сейчас"]</code></pre>
		<p>Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:</p>
		<pre><code>var arr = [1, 2, 5]
// начиная с позиции индексом -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4); // результат: 1,2,3,4,5</code></pre>
		<h3>Метод slice</h3>
		<p>Метод <code>slice(begin, end)</code> копирует участок массива от <code>begin</code> до <code>end</code>, не включая <code>end</code>. Исходный массив при этом не меняется.</p>
		<pre><code>var arr = ["Почему", "надо", "учить", "JavaScript"];
var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)
alert(arr2); // надо, учить</code></pre>
		<p>Аргументы ведут себя так же, как и в строковом <code>slice</code>:</p>
		<ul>
			<li>Если не указать <code>end</code> – копирование будет до конца массива</li>
			<li>Можно использовать отрицательные индексы, они отсчитываются с конца</li>
			<li>Если вообще не указать аргументов – скопируется весь массив</li>
		</ul>
		<h3>Сортировка, метод sort(fn)</h3>
		<p>Метод <code>sort()</code> сортирует массив на месте. Например:</p>
		<pre><code>var arr = [ 1, 2, 15 ];
arr.sort();
alert(arr);  // 1, 15, 2</code></pre>
		<h3>Свой порядок сортировки</h3>
		<p>Для указания своего порядка сортировки в метод <code>arr.sort(fn)</code> нужно передать функцию <code>fn</code> от двух элементов, которая умеет сравнивать их.</p>
		<p>Например, укажем эту функцию явно, отсортируем элементы массива как числа:</p>
		<pre><code>function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a < b) return -1;
}
var arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15</code></pre>
		<h3>reverse</h3>
		<p>Метод <code>arr.reverse()</code> меняет порядок элементов в массиве на обратный.</p>
		<pre><code>var arr = [1, 2, 3];
arr.reverse(); // 3,2,1</code></pre>
		<h3>concat</h3>
		<p>Метод <code>arr.concat(value1, value2, … valueN)</code> создаёт новый массив, в который копируются элементы из <code>arr</code>, а также <code>value1, value2, ... valueN</code>.</p>
		<pre><code>var arr = [1, 2];
var newArr = arr.concat(3, 4); // newArr = [1,2,3,4]</code></pre>
		<h3>indexOf/lastIndexOf</h3>
		<p>Метод <code>arr.indexOf(searchElement[, fromIndex])</code> возвращает номер элемента <code>searchElement</code> в массиве <code>arr</code> или <code>-1</code>, если его нет.</p>
		<p>Поиск начинается с номера <code>fromIndex</code>, если он указан. Если нет – с начала массива.</p>
		<p>Для поиска используется строгое сравнение <code>===</code>.</p>
		<pre><code>var arr = [1, 0, false];
alert(arr.indexOf(0)); // 1
alert(arr.indexOf(false)); // 2
alert(arr.indexOf(null)); // -1</code></pre>
		<p>Метод <code>arr.lastIndexOf(searchElement[, fromIndex])</code> ищет справа-налево: с конца массива или с номера <code>fromIndex</code>, если он указан.</p>
		<h3>Object.keys(obj)</h3>
		<p>Если мы хотим работать с объектом в виде массива, то к нашим услугам – замечательный метод <code>Object.keys(obj)</code>. Он поддерживается везде, кроме IE8-:</p>
		<pre><code>var user = {
  name: "Петя",
  age: 30
}
var keys = Object.keys(user);
alert(keys); // name, age</code></pre>
	</div>

	<div class="chapter"><h2>Массивы. Перебирающие методы массивов</h2>
		<h3>forEach</h3>
		<p>Метод <code>arr.forEach(callback[, thisArg])</code> используется для перебора массива.</p>
		<p>Он для каждого элемента массива вызывает функцию <code>callback</code>.</p>
		<p>Этой функции он передаёт три параметра <code>callback(item, i, arr)</code>:</p>
		<ul>
			<li><code>item</code> – очередной элемент массива.</li>
			<li><code>i</code> – его номер.</li>
			<li><code>arr</code> – массив, который перебирается.</li>
		</ul>
		<pre><code>["Яблоко", "Апельсин", "Груша"].forEach(function(item, i, arr) {
  alert(i + ": " + item + " (массив:" + arr + ")");
});</code></pre>
		<p>Второй, необязательный аргумент <code>forEach</code> позволяет указать контекст <code>this</code> для <code>callback</code>.</p>
		<h3>filter</h3>
		<p>Метод <code>arr.filter(callback[, thisArg])</code> используется для фильтрации массива через функцию.</p>
		<p>Он создаёт новый массив, в который войдут только те элементы <code>arr</code>, для которых вызов <code>callback(item, i, arr)</code> возвратит <code>true</code>.</p>
		<pre><code>var positiveArr = [1, -1, 2, -2, 3].filter(function(number) {
  return number > 0;
});
alert(positiveArr); // 1,2,3</code></pre>
		<h3>map</h3>
		<p>Метод <code>arr.map(callback[, thisArg])</code> используется для трансформации массива.</p>
		<p>Он создаёт новый массив, который будет состоять из результатов вызова <code>callback(item, i, arr)</code> для каждого элемента <code>arr</code>.</p>
		<pre><code>var nameLengths = ['HTML', 'CSS', 'JavaScript'].map(function(name) {
  return name.length;
});
// получили массив с длинами
alert(nameLengths); // 4,3,10</code></pre>
		<h3>every/some</h3>
		<p>Эти методы используются для проверки массива.</p>
		<ul>
			<li>Метод <code>arr.every(callback[, thisArg])</code> возвращает <code>true</code>, если вызов <code>callback</code> вернёт <code>true</code> для каждого элемента <code>arr</code>.</li>
			<li>Метод <code>arr.some(callback[, thisArg])</code> возвращает <code>true</code>, если вызов <code>callback</code> вернёт <code>true</code> для какого-нибудь элемента <code>arr</code>.</li>
		</ul>
		<pre><code>function isPositive(number) {
  return number > 0;
}
alert([1, -1, 2, -2, 3].every(isPositive)); // false, не все положительные
alert([1, -1, 2, -2, 3].some(isPositive)); // true, есть хоть одно положительное</code></pre>
		<h3>reduce/reduceRight</h3>
		<p>Метод <code>arr.reduce(callback[, initialValue])</code> используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.</p>
		<p>Метод <code>reduce</code> используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива». Чуть далее мы разберём пример для вычисления суммы.</p>
		<p>Он применяет функцию <code>callback</code> по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.</p>
		<p>Аргументы функции <code>callback(previousValue, currentItem, index, arr)</code>:</p>
		<ul>
			<li><code>previousValue</code> – последний результат вызова функции, он же «промежуточный результат».</li>
			<li><code>currentItem</code> – текущий элемент массива, элементы перебираются по очереди слева-направо.</li>
			<li><code>index</code> – номер текущего элемента</li>
			<li><code>arr</code> – обрабатываемый массив.</li>
		</ul>
		<p>Кроме <code>callback</code>, методу можно передать «начальное значение» – аргумент <code>initialValue</code>. Если он есть, то на первом вызове значение <code>previousValue</code> будет равно <code>initialValue</code>, а если у <code>reduce</code> нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.</p>
		<pre><code>var arr = [1, 2, 3, 4, 5]
var result = arr.reduce(function(sum, current) {
  return sum + current;
}, 0);
alert(result); // 15</code></pre>
	</div>
	
	<div class="chapter"><h2>Дата и Время</h2>
		<h3>Создание</h3>
		<p>Для создания нового объекта типа <code>Date</code> используется один из синтаксисов:</p>
		<p><b>new Date()</b></p>
		<p>Создает объект <code>Date</code> с текущей датой и временем:</p>
		<pre><code>var now = new Date();</code></pre>
		<p><b>new Date(milliseconds)</b></p>
		<p>Создает объект <code>Date</code>, значение которого равно количеству миллисекунд (1/1000 секунды), прошедших с 1 января 1970 года GMT+0.</p>
		<pre><code>// 24 часа после 01.01.1970 GMT+0
var Jan02_1970 = new Date(3600 * 24 * 1000);</code></pre>
		<p><b>new Date(datestring)</b></p>
		<p>Если единственный аргумент – строка, используется вызов <code>Date.parse</code> (см. далее) для чтения даты из неё.</p>
		<p><b>new Date(year, month, date, hours, minutes, seconds, ms)</b></p>
		<p>Дату можно создать, используя компоненты в местной временной зоне. Для этого формата обязательны только первые два аргумента. Отсутствующие параметры, начиная с <code>hours</code> считаются равными нулю, а <code>date</code> – единице.</p>
		<pre><code>new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 января 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, часы/секунды по умолчанию равны 0</code></pre>
		<h3>Получение компонентов даты</h3>
		<p>Для доступа к компонентам даты-времени объекта <code>Date</code> используются следующие методы:</p>
		<p><b>getFullYear()</b></p>
		<p>Получить год (из 4 цифр)</p>
		<p><b>getMonth()</b></p>
		<p>Получить месяц, от 0 до 11.</p>
		<p><b>getDate()</b></p>
		<p>Получить число месяца, от 1 до 31.</p>
		<p><b>getHours(), getMinutes(), getSeconds(), getMilliseconds()</b></p>
		<p>Получить соответствующие компоненты.</p>
		<p><b>getDay()</b></p>
		<p>Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота).</p>
		<p>Все методы, указанные выше, возвращают результат для местной временной зоны.</p>
		<p>Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): <code>getUTCFullYear()</code>, <code>getUTCMonth()</code>, <code>getUTCDay()</code>. То есть, сразу после <code>"get"</code> вставляется <code>"UTC"</code>.</p>
		<p>Кроме описанных выше, существуют два специальных метода без UTC-варианта:</p>
		<p><b>getTime()</b></p>
		<p>Возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0, то есть того же вида, который используется в конструкторе <code>new Date(milliseconds)</code>.</p>
		<p><b>getTimezoneOffset()</b></p>
		<p>Возвращает разницу между местным и UTC-временем, в минутах.</p>
		<pre><code>alert( new Date().getTimezoneOffset() ); // Для GMT-1 выведет 60</code></pre>
		<h3>Установка компонентов даты</h3>
		<p>Следующие методы позволяют устанавливать компоненты даты и времени:</p>
		<ul>
			<li><code>setFullYear(year [, month, date])</code></li>
			<li><code>setMonth(month [, date])</code></li>
			<li><code>setDate(date)</code></li>
			<li><code>setHours(hour [, min, sec, ms])</code></li>
			<li><code>setMinutes(min [, sec, ms])</code></li>
			<li><code>setSeconds(sec [, ms])</code></li>
			<li><code>setMilliseconds(ms)</code></li>
			<li><code>setTime(milliseconds)</code> (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)</li>
		</ul>
		<p>Все они, кроме <code>setTime()</code>, обладают также UTC-вариантом, например: <code>setUTCHours()</code>.</p>
		<pre><code>var today = new Date;
today.setHours(0); // сегодня, но час изменён на 0</code></pre>
		<h3>Бенчмаркинг</h3>
		<p><b>performance.now()</b></p>
		<p>В современных браузерах (кроме IE9-) вызов <code>performance.now()</code> возвращает количество миллисекунд, прошедшее с начала загрузки страницы.</p>
		<p><b>console.time(метка) и console.timeEnd(метка)</b></p>
		<p>Для измерения с одновременным выводом результатов в консоли есть методы:</p>
		<ul>
			<li><code>console.time(метка)</code> – включить внутренний хронометр браузера с меткой.</li>
			<li><code>console.timeEnd(метка)</code> – выключить внутренний хронометр браузера с меткой и вывести результат.</li>
		</ul>
		<h3>Разбор строки, Date.parse</h3>
		<p>Метод <code>Date.parse(str)</code> разбирает строку <code>str</code> в таком формате и возвращает соответствующее ей количество миллисекунд. Если это невозможно, <code>Date.parse</code> возвращает <code>NaN</code>.</p>
		<p>Этот формат выглядит так: <code>YYYY-MM-DDTHH:mm:ss.sssZ</code>, где:</p>
		<ul>
			<li><code>YYYY-MM-DD</code> – дата в формате год-месяц-день.</li>
			<li>Обычный символ <code>T</code> используется как разделитель.</li>
			<li><code>HH:mm:ss.sss</code> – время: часы-минуты-секунды-миллисекунды.</li>
			<li>Часть <code>'Z'</code> обозначает временную зону – в формате <code>+-hh:mm</code>, либо символ <code>Z</code>, обозначающий UTC. По стандарту её можно не указывать, тогда UTC, но в Safari с этим ошибка, так что лучше указывать всегда.</li>
		</ul>
		<p>Также возможны укороченные варианты, например <code>YYYY-MM-DD</code> или <code>YYYY-MM</code> или даже только <code>YYYY</code>.</p>
		<pre><code>var msUTC = Date.parse('2012-01-26T13:51:50.417Z'); // зона UTC
alert( msUTC ); // 1327571510417 (число миллисекунд)</code></pre>
		<p>С таймзоной <code>-07:00 GMT</code>:</p>
		<pre><code>var ms = Date.parse('2012-01-26T13:51:50.417-07:00');
alert( ms ); // 1327611110417 (число миллисекунд)</code></pre>
	</div>

</div></body>

</html>