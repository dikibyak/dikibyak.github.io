<!DOCTYPE html>
<html lang="ru" dir="ltr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../files/css/master.css">
    <script async src="../files/js/main_script.js"></script>
    <title>Свойства узлов: тип, тег и содержимое</title>
  </head>
  <body>
<div class="wrapper">
  <div class="back"><a href="../index.html">&lt;</a></div>
  <h2>Классы, иерархия DOM</h2>
  <p>Самое главное различие между DOM-узлами – разные узлы являются объектами различных классов.</p>
  <p>Классы DOM образуют иерархию.</p>
  <p>Основной объект в ней: Node, от которого наследуют остальные:</p>
  <img src="../files/img/hierarchy.png">
  <p>На рисунке выше изображены основные классы:</p>
  <ul>
    <li>Прямо от <code>Node</code> наследуют текстовые узлы <code>Text</code>, комментарии <code>Comment</code> и элементы <code>Element</code>.</li>
    <li>Элементы <code>Element</code> – это ещё не HTML-элементы, а более общий тип, который используется в том числе в XML. От него наследует <code>SVGElement</code> для SVG-графики и, конечно, <code>HTMLElement</code>.</li>
    <li>От <code>HTMLElement</code> уже наследуют разнообразные узлы HTML:<ul>
      <li>Для <code>&lt;input></code> – <code>HTMLInputElement</code></li>
      <li>Для <code>&lt;body></code> – <code>HTMLBodyElement</code></li>
      <li>Для <code>&lt;a></code> – <code>HTMLAnchorElement</code>… и так далее.</li>
    </ul></li>
  </ul>
  <p>Узнать класс узла очень просто – достаточно привести его к строке, к примеру, вывести:</p>
<pre><code>alert( document.body ); // [object HTMLBodyElement]</code></pre>
  <p>Как видно, DOM-узлы – обычные JavaScript-объекты. Их классы заданы в прототипном стиле. В этом легко убедиться, если вывести в консоли любой элемент через <code>console.dir(elem)</code>. Или даже можно напрямую обратиться к методам, которые хранятся в <code>Node.prototype</code>, <code>Element.prototype</code> и так далее.</p>
  <h2>Тип: nodeType</h2>
  <p>Тип узла содержится в его свойстве <code>nodeType</code>.</p>
  <p>Как правило, мы работаем всего с двумя типами узлов:</p>
  <ul>
    <li>Элемент.</li>
    <li>Текстовый узел.</li>
  </ul>
  <p>На самом деле типов узлов гораздо больше. Строго говоря, их 12, и они описаны в спецификации с древнейших времён, см. DOM Уровень 1:</p>
<pre><code>interface Node {
  // Всевозможные значения nodeType
  const unsigned short ELEMENT_NODE = 1;
  const unsigned short ATTRIBUTE_NODE = 2;
  const unsigned short TEXT_NODE = 3;
  const unsigned short CDATA_SECTION_NODE = 4;
  const unsigned short ENTITY_REFERENCE_NODE = 5;
  const unsigned short ENTITY_NODE = 6;
  const unsigned short PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short COMMENT_NODE = 8;
  const unsigned short DOCUMENT_NODE = 9;
  const unsigned short DOCUMENT_TYPE_NODE = 10;
  const unsigned short DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short NOTATION_NODE = 12;
  ...
}</code></pre>
  <p>В частности, тип «Элемент» <code>ELEMENT_NODE</code> имеет номер 1, а «Текст» <code>TEXT_NODE</code> – номер 3.</p>
  <p>Например, выведем все узлы-потомки <code>document.body</code>, <i>являющиеся элементами</i>:</p>
<pre><code>&lt;body>
  &lt;div>Читатели:&lt;/div>
  &lt;ul>
    &lt;li>Вася&lt;/li>
    &lt;li>Петя&lt;/li>
  &lt;/ul>

  &lt;!-- комментарий -->

  &lt;script>
    var childNodes = document.body.childNodes;

    for (var i = 0; i &lt; childNodes.length; i++) {

      // отфильтровать не-элементы
      if (childNodes[i].nodeType != 1) continue;

      alert( childNodes[i] );

    }
  &lt;/script>
&lt;/body></code></pre>
  <h2>Тег: nodeName и tagName</h2>
  <p>Существует целых два свойства: <code>nodeName</code> и <code>tagName</code>, которые содержат название(тег) элемента узла.</p>
  <p>Например, для <code>document.body</code>:</p>
<pre><code>alert( document.body.nodeName ); // BODY
alert( document.body.tagName ); // BODY</code></pre>
  <h3>Какая разница между tagName и nodeName?</h3>
  <ul>
    <li>Свойство <code>tagName</code> есть только у элементов <code>Element</code> (в IE8- также у комментариев, но это ошибка в браузере).</li>
    <li>Свойство <code>nodeName</code> определено для любых узлов <code>Node</code>, для элементов оно равно <code>tagName</code>, а для не-элементов обычно содержит строку с типом узла.</li>
  </ul>
  <p>Таким образом, при помощи <code>tagName</code> мы можем работать только с элементами, а <code>nodeName</code> может что-то сказать и о других типах узлов.</p>
  <h2>innerHTML: содержимое элемента</h2>
  <p>Свойство <code>innerHTML</code> позволяет получить HTML-содержимое элемента в виде строки. В <code>innerHTML</code> можно и читать и писать.</p>
  <p>Пример выведет на экран все содержимое <code>document.body</code>, а затем заменит его на другое:</p>
<pre><code>&lt;body>
  &lt;p>Параграф&lt;/p>
  &lt;div>Div&lt;/div>

  &lt;script>
    alert( document.body.innerHTML ); // читаем текущее содержимое
    document.body.innerHTML = 'Новый BODY!'; // заменяем содержимое
  &lt;/script>

&lt;/body></code></pre>
  <p>Свойство <code>innerHTML</code> – одно из самых часто используемых.</p>
  <h3>Тонкости innerHTML</h3>
  <ul>
    <li>Для таблиц в IE9- – <code>innerHTML</code> только для чтения.</li>
    <li>Добавление <code>innerHTML+=</code> осуществляет перезапись.</li>
    <li>Скрипты не выполняются.</li>
    <li>IE8- обрезает <code>style</code> и <code>script</code> в начале codeinnerHTML.</li>
  </ul>
  <h2>outerHTML: HTML элемента целиком</h2>
  <p>Свойство <code>outerHTML</code> содержит HTML элемента целиком.</p>
  <p>Пример чтения <code>outerHTML</code>:</p>
<pre><code>&lt;div>Привет &lt;b>Мир&lt;/b>&lt;/div>

&lt;script>
  var div = document.body.children[0];

  alert( div.outerHTML ); // &lt;div>Привет &lt;b>Мир&lt;/b>&lt;/div>
&lt;/script></code></pre>
  <p>Изменить <code>outerHTML</code> элемента невозможно.</p>
  <h2>nodeValue/data: содержимое текстового узла</h2>
  <p>Свойство <code>innerHTML</code> есть только у узлов-элементов.</p>
  <p>Содержимое других узлов, например, текстовых или комментариев, доступно на чтение и запись через свойство <code>data</code>.</p>
  <p>Его тоже можно читать и обновлять. Следующий пример демонстрирует это:</p>
<pre><code>&lt;body>
  Привет
  &lt;!-- Комментарий -->
  &lt;script>
    for (var i = 0; i &lt; document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i].data );
    }
  &lt;/script>
  Пока
&lt;/body></code></pre>
  <p>Свойство <code>nodeValue</code> работает так же, как <code>data</code>, но на некоторых узлах, где <code>data</code> нет, <code>nodeValue</code> есть и имеет значение <code>null</code>.</p>
  <h2>Текст: textContent</h2>
  <p>Свойство <code>textContent</code> содержит только текст внутри элемента, за вычетом всех <code><тегов></code>.</p>
<pre><code>&lt;div>
  &lt;h1>Срочно в номер!&lt;/h1>
  &lt;p>Марсиане атакуют людей!&lt;/p>
&lt;/div>

&lt;script>
  var news = document.body.children[0];

  // \n  Срочно в номер!\n  Марсиане атакуют людей!\n
  alert( news.textContent );
&lt;/script></code></pre>
  <p>Иными словами, <code>elem.textContent</code> возвращает конкатенацию всех текстовых узлов внутри <code>elem</code>.</p>
  <p>В этом примере имя посетителя попадёт в первый <code>div</code> как <code>innerHTML</code>, а во второй – как текст:</p>
<pre><code>&lt;div>&lt;/div>
&lt;div>&lt;/div>

&lt;script>
  var name = prompt("Введите имя?", "<b>Винни-пух</b>");

  document.body.children[0].innerHTML = name;
  document.body.children[1].textContent = name;
&lt;/script></code></pre>
  <h2>Свойство hidden</h2>
  <p>Технически, атрибут <code>hidden</code> работает так же, как <code>style="display:none"</code>. Но его проще поставить через JavaScript (меньше букв), и могут быть преимущества для скринридеров и прочих нестандартных браузеров.</p>
<pre><code>&lt;div>Текст&lt;/div>
&lt;div hidden>С атрибутом hidden&lt;/div>
&lt;div>Со свойством hidden&lt;/div>

&lt;script>
  var lastDiv = document.body.children[2];
  lastDiv.hidden = true;
&lt;/script></code></pre>
</div>
  </body>
</html>
