<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="files/css/master.css">
    <script async src="files/js/main_script.js"></script>
  </head>
  <body>
    <div class="wrapper">
<div class="back"><a href="index.html">&lt;</a></div>

      <h1>Глобальный объект</h1><hr>
      <p>В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется "глобальный объект" (global object).</p>
      <p>В браузере этот объект явно доступен под именем window.</p>
      <p>Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window.</p>
      <pre><code>var a = 5; // объявление var создаёт свойство window.a
alert( window.a ); // 5</code></pre>
      <h2>Порядок инициализации</h2>
      <pre><code>// На момент инициализации, до выполнения кода:
// window = { f: function, a: undefined, g: undefined }</code></pre>
      <pre><code>var a = 5;
// window = { f: function, a: 5, g: undefined }</code></pre>
      <pre><code>function f(arg) { /*...*/ }
// window = { f: function, a: 5, g: undefined } без изменений, f обработана ранее</code></pre>
      <pre><code>var g = function(arg) { /*...*/ };
// window = { f: function, a: 5, g: function }</code></pre>
      <h1>Замыкания, функции изнутри</h1><hr>
      <h2>Лексическое окружение</h2>
      <p>Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.</p>
      <p>При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.</p>
      <p>В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.</p>
      <h2>Доступ ко внешним переменным</h2>
      <p>Из функции мы можем обратиться не только к локальной переменной, но и к внешней:</p>
      <pre><code>var userName = "Вася";

function sayHi() {
  alert( userName ); // "Вася"
}</code></pre>
      <p>Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. В данном случае им является window.</p>
      <p>При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана.</p>
      <p>В примере выше таким окружением является window, так что создаётся свойство:</p>
      <pre><code>sayHi.[[Scope]] = window</code></pre>
      <p>Если обобщить:</p>
      <ul>
        <li>Каждая функция при создании получает ссылку [[Scope]] на объект с переменными, в контексте которого была создана.</li>
        <li>При запуске функции создаётся новый объект с переменными LexicalEnvironment. Он получает ссылку на внешний объект переменных из [[Scope]].</li>
        <li>При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке.</li>
      </ul>
      <h1>[[Scope]] для new Function</h1><hr>
      <h2>Присвоение [[Scope]] для new Function</h2>
      <p>При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.</p>
      <pre><code>var a = 1;

function getFunc() {
  var a = 2;
  var func = new Function('', 'alert(a)');

  return func;
}

getFunc()(); // 1, из window</code></pre>
      <h1>Локальные переменные для объекта</h1><hr>
      <h2>Объект счётчика + функция</h2>
      <pre><code>function makeCounter() {
  var currentCount = 1;

  // возвращаемся к функции
  function counter() {
    return currentCount++;
  }

  // ...и добавляем ей методы!
  counter.set = function(value) {
    currentCount = value;
  };

  counter.reset = function() {
    currentCount = 1;
  };

  return counter;
}

var counter = makeCounter();

alert( counter() ); // 1
alert( counter() ); // 2

counter.set(5);
alert( counter() ); // 5</code></pre>
      <h1>Модули через замыкания</h1><hr>
      <p>Его цель – скрыть внутренние детали реализации скрипта. В том числе: временные переменные, константы, вспомогательные мини-функции и т.п.</p>
      <h2>Приём проектирования «Модуль»</h2>
      <p>Чтобы проблемы не было, всего-то нужно, чтобы у скрипта была своя собственная область видимости, чтобы его переменные не попали на страницу.</p>
      <p>Для этого мы завернём всё его содержимое в функцию, которую тут же запустим.</p>
      <pre><code>(function() {

  // глобальная переменная нашего скрипта
  var message = "Привет";

  // функция для вывода этой переменной
  function showMessage() {
    alert( message );
  }

  // выводим сообщение
  showMessage();

})();</code></pre>
      <h3>Зачем скобки вокруг функции?</h3>
      <p>В начале и в конце стоят скобки, так как иначе была бы ошибка.</p>
      <p>Ошибка при запуске без скобок произойдет потому, что браузер, видя ключевое слово function в основном потоке кода, попытается прочитать Function Declaration, а здесь имени нет.</p>
      <p>«На месте» разрешено вызывать только Function Expression.</p>
      <h1>Устаревшая конструкция "with"</h1><hr>
      <p>Конструкция with позволяет использовать в качестве области видимости для переменных произвольный объект.</p>
      <pre><code>var a = 5;

var obj = {
  a: 10
};

with(obj) {
  alert( a ); // 10, из obj
}</code></pre>
      <h2>Замена with</h2>
      <p>Вместо with рекомендуется использовать временную переменную, например:</p>
      <pre><code>/* вместо
with(elem.style) {
  top = '10px';
  left = '20px';
}
*/

var s = elem.style;

s.top = '10px';
s.left = '0';</code></pre>

    </div>
  </body>
</html>
