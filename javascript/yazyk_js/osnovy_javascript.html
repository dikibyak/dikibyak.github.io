<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="files/css/master.css">
    <script async src="files/js/main_script.js"></script>
  </head>
  <body>
    <div class="wrapper">
<div class="back"><a href="index.html">&lt;</a></div>

      <h1>Взаимодействие с пользователем</h1><hr>
  		<h3>alert(сообщение);</h3>
  		<p>Выводит на экран окно с сообщением и приостанавливает выполнение скрипта, пока пользователь не нажмет «ОК» (модальное окно).</p>
  		<h3>prompt(title, default);</h3>
  		<p>Модальное окно с заголовком <code>title</code>, полем для ввода текста, заполненным строкой по умолчанию (<code>default</code>) и кнопками OK / CANCEL. Вызов <code>prompt</code>, возвращает то, что ввел посетитель — в строку или специальное значение <code>null</code>, если ввод отменен.</p>
  		<h3>confirm(question);</h3>
  		<p>Выводит окно с вопросом <code>question</code> с двумя кнопками: OK и CANCEL. Результатом будет <code>true</code> при нажатии OK и <code>false</code> — при CANCEL.</p>
  		<h1>Внешние скрипты, порядок исполнения</h1><hr>
  		<pre><code>&lt;script async src = "…">&lt;/script>;</code></pre>
  		<p>Браузер не останавливает обработку страницы, а работает дальше. Когда скрипт будет загружен – он выполнится. Последовательность скриптов не будет сохранена.</p>
  		<pre><code>&lt;script defer src = "…">&lt;/script>;</code></pre>
  		<p>Браузер не останавливает обработку страницы, а работает дальше. Когда скрипт будет загружен – он выполнится. Последовательность скриптов будет сохранена.</p>
  		<p>При одновременном указании async и defer в современных браузерах будет использован только async, в IE9 — только defer (не понимает async).</p>
  		<p>Атрибуты async/defer работают только в том случае, если назначены на внешние скрипты, т.е. имеющие src. При попытке назначить их на обычные скрипты, они будут проигнорированы.</p>
  		<h1>Преобразование типов для примитивов</h1><hr>
  		<h3>Численное преобразование</h3>
  		<ol>
  			<li><code>Number(val);</code></li>
  			<li>Оператор "<code>+</code>" перед аргументом</li>
  		</ol>
  		<pre><code>var a = +"123"; // 123
var a = Number("123"); // 123, тот же эффект</code></pre>
  		<h3>Строковое преобразование</h3>
  		<ol>
  			<li><code>String(val);</code></li>
  			<li>Оператор "<code>+</code>", у которого один аргумент строка</li>
  		</ol>
  		<pre><code>alert(String(null) === "null"); // true
alert("123" + undefined); // "123undefined"</code></pre>
  		<h3>Логическое преобразование</h3>
  		<ol>
  			<li><code>Boolean(val);</code></li>
  			<li><code>if(val)</code></li>
  			<li><code>!!val</code></li>
  		</ol>
  		<pre><code>alert(!!"0"); // true
var a = Boolean(1); // true</code></pre>
  		<h3>Тип данных typeof</h3>
  		<p>typeof возвращает тип данных</p>
  		<pre><code>typeof undefined	// "undefined"
typeof 0		// "number"
typeof true		// "boolean"
typeof "foo"		// "string"
typeof {}		// "object"
typeof null		// "null"
typeof function(){}  	// "function"</code></pre>
  		<h1>Функции</h1><hr>
  		<h3>Function Declaration</h3>
  		<pre><code>function greet(name) {
  return "Hello, " + name;
}
console.log(greet(Andrey));</code></pre>
  		<h3>Function Expression</h3>
  		<pre><code>var greet = function(name) {
  return "Hello, " + name;
};
greet("Andrey");</code></pre>
  		<p>Основное различие между ними: функции, объявленные как <code>Function Declaration</code>, создаются интерпретатором до выполнения кода.</p>
  		<h3>Вызов функции сразу после определения</h3>
  		<pre><code>var greeting = (function(name) {
  return "Hello, " + name;
}("Andrew"));
console.log(greeting);</code></pre>
  		<h3>Анонимные функци</h3>
  		<pre><code>function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);</code></pre>
  		<h3>new Function</h3>
  		<p>Позволяет создавать функцию полностью «на лету» из строки, вот так:</p>
  		<pre><code>var sum = new Function('a, b', 'return a+b;');
alert(sum(1, 2)); // 3</code></pre>
  		<h1>Побитовые операции</h1><hr>
  		<h3>Формат 32-битного целого числа со знаком</h3>
  		<p>Побитовые операторы в JavaScript работают с 32-битными целыми числами в их двоичном представлении.</p>
  		<p>Побитовые операторы интерпретируют операнды как последовательность из 32 битов (нулей и единиц). Они производят операции, используя двоичное представление числа, и возвращают новую последовательность из 32 бит (число) в качестве результата.</p>
  		<pre><code>a = 0;  // 00000000000000000000000000000000
a = 1;  // 00000000000000000000000000000001
a = 2;  // 00000000000000000000000000000010
a = 3;  // 00000000000000000000000000000011
a = 255;// 00000000000000000000000011111111</code></pre>
  		<p>Двоичный вид числа, обратного данному (например, 5 и -5) получается путём обращения всех битов с прибавлением 1. То есть, нули заменяются на единицы, единицы – на нули и к числу прибавляется 1. Получается внутреннее представление того же числа, но со знаком минус.</p>
  		<p>Например, число 314:</p>
  		<pre><code>00000000000000000000000100111010</code></pre>
  		<p>Чтобы получить -314, первый шаг – обратить биты числа: заменить 0 на 1, а 1 на 0:</p>
  		<pre><code>11111111111111111111111011000101</code></pre>
  		<p>Чтобы получить -314, первый шаг – обратить биты числа: заменить 0 на 1, а 1 на 0:</p>
  		<pre><code>11111111111111111111111011000101</code></pre>
  		<p>Второй шаг – к полученному числу прибавить единицу, обычным двоичным сложением:</p>
  		<pre><code>11111111111111111111111011000101 + 1 = 11111111111111111111111011000110</code></pre>
  		<p>Итак, мы получили:</p>
  		<pre><code>-314 = 11111111111111111111111011000110</code></pre>
  		<h3>Список операторов</h3>
  		<table>
  			<tr>
  				<th>Операции</th><th>Список операторов</th><th>Описание</th>
  			</tr>
  			<tr>
  				<td>Побитовое И (AND)</td><td><code>a & b</code></td><td>Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1</td>
  			</tr>
  			<tr>
  				<td>Побитовое ИЛИ (OR)</td><td><code>a | b</code></td><td>Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1</td>
  			</tr>
  			<tr>
  				<td>Побитовое исключающее ИЛИ (XOR)</td><td><code>a ^ b</code></td><td>Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба)</td>
  			</tr>
  			<tr>
  				<td>Побитовое НЕ (NOT)</td><td><code>~a</code></td><td>Заменяет каждый бит операнда на противоположный</td>
  			</tr>
  			<tr>
  				<td>Левый сдвиг</td><td><code>`a << b`</code></td><td>Сдвигает двоичное представление a на b битов влево, добавляя справа нули</td>
  			</tr>
  			<tr>
  				<td>Правый сдвиг, переносящий знак</td><td><code>`a >> b`</code></td><td>Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты</td>
  			</tr>
  			<tr>
  				<td>Правый сдвиг с заполнением нулями</td><td><code>`a >>> b`</code></td><td>Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева</td>
  			</tr>
  		</table>
  		<h3>Исключающее ИЛИ в шифровании</h3>
  		<p>Исключающее или можно использовать для шифрования, так как эта операция полностью обратима. Двойное применение исключающего ИЛИ с тем же аргументом даёт исходное число.</p>
  		<p>Иначе говоря, верна формула: a ^ b ^ b == a.</p>
  		<p>Например.</p>
  		<p>X берет двоичное представление data и делает операцию data ^ key. Результат data ^ key отправляется Y, это шифровка.</p>
  		<p>Данные: 9 в двоичном виде</p>
  		<pre><code>00000000000000000000000000001001</code></pre>
  		<p>Ключ: 1220461917 в двоичном виде</p>
  		<pre><code>01001000101111101100010101011101</code></pre>
  		<p>Результат операции 9 ^ key</p>
  		<pre><code>01001000101111101100010101010100</code></pre>
  		<p>Результат в 10-ной системе (шифровка):</p>
  		<pre><code>1220461908</code></pre>
  		<p>Y, получив очередное число шифровки 1220461908, применяет к нему такую же операцию ^ key. Результатом будет исходное число data.</p>
  		<p>Результат операции 1220461917 ^ key:</p>
  		<pre><code>00000000000000000000000000001001</code></pre>
  		<p>Результат в 10-ной системе (исходное сообщение):</p>
  		<pre><code>9</code></pre>
  		<h3>Вспомогательные функции parseInt, toString</h3>
  		<p><code>parseInt("11000", 2);</code> – переводит строку с двоичной записью числа в число</p>
  		<p><code>n.toString(2);</code> – получает для числа n запись в 2-ной системе в виде строки</p>
  		<pre><code>var access = parseInt("11000", 2); // получаем число из строки
alert( access ); // 24, число с таким 2-ным представлением</code></pre>
  		<pre><code>var access2 = access.toString(2); // обратно двоичную строку из числа
alert( access2 ); // 11000</code></pre>

    </div>
  </body>
</html>
